#cloud-config
# -*- YAML -*-
package_upgrade: true
locale: es_ES.UTF-8
packages:
 - traceroute
 - nmap
 - keepalived
write_files:
-   path: /lib/systemd/system/awsnycast.service
    content: |
        [Unit]
        Description=Job that runs AWSnycast

        [Service]
        Type=simple
        ExecStart=/usr/bin/AWSnycast
-   path: /etc/awsnycast.yaml
    content: |
        ---
        poll_time: 300
        healthchecks:
            public:
                type: ping
                destination: 8.8.8.8
                rise: 2
                fall: 10
                every: 1
        routetables:
             my_az:
                find:
                    type: subnet
                    config:
                        subnet_id: ${mysubnet}
                manage_routes:
                   - cidr: 0.0.0.0/0
                     instance: SELF
                     healthcheck: public
                     never_delete: true
             other_azs:
                find:
                    type: and
                    config:
                        filters:
                          - type: subnet
                            not: true
                            config:
                                subnet_id: ${mysubnet}
                          - type: by_tag_regexp
                            config:
                                key: Name
                                regexp: ${name}-${identifier}-${region}[a-z]
                manage_routes:
                  - cidr: 0.0.0.0/0
                    instance: SELF
                    healthcheck: public
                    if_unhealthy: true
-   path: ~/mycron
    content: |
        */5 * * * * /usr/bin/bastion/sync_s3
        */5 * * * * /usr/bin/bastion/sync_users
        0 0 * * * yum -y update --security
-   path: /usr/bin/bastion/shell
    content: |
        # Check that the SSH client did not supply a command
        if [[ -z $SSH_ORIGINAL_COMMAND ]]; then
          # The format of log files is /var/log/bastion/YYYY-MM-DD_HH-MM-SS_user
          LOG_FILE="`date --date="today" "+%Y-%m-%d_%H-%M-%S"`_`whoami`"
          LOG_DIR="/var/log/bastion/"
          # Print a welcome message
          echo ""
          echo "NOTE: This SSH session will be recorded"
          echo "AUDIT KEY: $LOG_FILE"
          echo ""
          # I suffix the log file name with a random string. I explain why later on.
          SUFFIX=`mktemp -u _XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX`
          # Wrap an interactive shell into "script" to record the SSH session
          script -qf --timing=$LOG_DIR$LOG_FILE$SUFFIX.time $LOG_DIR$LOG_FILE$SUFFIX.data --command=/bin/bash
        else
          # The "script" program could be circumvented with some commands (e.g. bash, nc).
          # Therefore, I intentionally prevent users from supplying commands.
          echo "This bastion supports interactive sessions only. Do not supply a command"
          exit 1
        fi
-   path: /usr/bin/bastion/sync_s3
    permissions: '0700'
    content: |
        # Copy log files to S3 with server-side encryption enabled.
        # Then, if successful, delete log files that are older than a day.
        LOG_DIR="/var/log/bastion/"
        aws s3 cp $LOG_DIR s3://${bucket_name}/logs/ --sse --region ${aws_region} --recursive && find $LOG_DIR* -mtime +1 -exec rm {} \\;
-   path: /usr/bin/bastion/sync_users
    permissions: '0700'
    content: |
        # The file will log user changes
        LOG_FILE="/var/log/bastion/users_changelog.txt"
        # The function returns the user name from the public key file name.
        # Example: public-keys/sshuser.pub => sshuser
        get_user_name () {
          echo "$1" | sed -e "s/.*\\///g" | sed -e "s/\\.pub//g"
        }
        # For each public key available in the S3 bucket
        aws s3api list-objects --bucket ${bucket_name} --prefix public-keys/ --region ${aws_region} --output text --query 'Contents[?Size>`0`].Key' | sed -e 's/\\t/\\n/' | sed -E -e 's/[[:blank:]]+/\n/g' > ~/keys_retrieved_from_s3
        while read line; do
          USER_NAME="`get_user_name "$line"`"
          # Make sure the user name is alphanumeric
          if [[ "$USER_NAME" =~ ^[a-z][-a-z0-9]*$ ]]; then
            # Create a user account if it does not already exist
            cut -d: -f1 /etc/passwd | grep -qx $USER_NAME
            if [ $? -eq 1 ]; then
              /usr/sbin/adduser $USER_NAME && \
              mkdir -m 700 /home/$USER_NAME/.ssh && \
              chown $USER_NAME:$USER_NAME /home/$USER_NAME/.ssh && \
              echo "$line" >> ~/keys_installed && \
              echo "`date --date="today" "+%Y-%m-%d %H-%M-%S"`: Creating user account for $USER_NAME ($line)" >> $LOG_FILE
            fi
            # Copy the public key from S3, if an user account was created from this key
            if [ -f ~/keys_installed ]; then
              grep -qx "$line" ~/keys_installed
              if [ $? -eq 0 ]; then
                aws s3 cp s3://${bucket_name}/$line /home/$USER_NAME/.ssh/authorized_keys --region ${aws_region}
                chmod 600 /home/$USER_NAME/.ssh/authorized_keys
                chown $USER_NAME:$USER_NAME /home/$USER_NAME/.ssh/authorized_keys
              fi
            fi
          fi
        done < ~/keys_retrieved_from_s3
        # Remove user accounts whose public key was deleted from S3
        if [ -f ~/keys_installed ]; then
          sort -uo ~/keys_installed ~/keys_installed
          sort -uo ~/keys_retrieved_from_s3 ~/keys_retrieved_from_s3
          comm -13 ~/keys_retrieved_from_s3 ~/keys_installed | sed "s/\\t//g" > ~/keys_to_remove
          while read line; do
            USER_NAME="`get_user_name "$line"`"
            echo "`date --date="today" "+%Y-%m-%d %H-%M-%S"`: Removing user account for $USER_NAME ($line)" >> $LOG_FILE
            /usr/sbin/userdel -r -f $USER_NAME
          done < ~/keys_to_remove
          comm -3 ~/keys_installed ~/keys_to_remove | sed "s/\\t//g" > ~/tmp && mv ~/tmp ~/keys_installed
        fi
# The commands below need to run on every boot, but bootcmd runs too early,
# before the write_files has run, but on every boot, where as runcmd only runs
# on the first time this instance is booted.
bootcmd:
  - mkdir /var/log/bastion
  - mkdir /usr/bin/bastion
  - [ sh, -c, "[ -x /var/lib/cloud/instance/scripts/runcmd ] && /var/lib/cloud/instance/scripts/runcmd" ]
runcmd:
 - [ sh, -c, "echo 1 > /proc/sys/net/ipv4/ip_forward;echo 655361 > /proc/sys/net/netfilter/nf_conntrack_max" ]
 - [ iptables, -N, LOGGINGF ]
 - [ iptables, -N, LOGGINGI ]
 - [ iptables, -A, LOGGINGF, -m, limit, --limit, 2/min, -j, LOG, --log-prefix, "IPTables-FORWARD-Dropped: ", --log-level, 4 ]
 - [ iptables, -A, LOGGINGI, -m, limit, --limit, 2/min, -j, LOG, --log-prefix, "IPTables-INPUT-Dropped: ", --log-level, 4 ]
 - [ iptables, -A, LOGGINGF, -j, DROP ]
 - [ iptables, -A, LOGGINGI, -j, DROP ]
 - [ iptables, -A, FORWARD, -s, ${vpc_cidr}, -j, ACCEPT ]
 - [ iptables, -A, FORWARD, -j, LOGGINGF ]
 - [ iptables, -P, FORWARD, DROP ]
 - [ iptables, -I, FORWARD, -m, state, --state, "ESTABLISHED,RELATED", -j, ACCEPT ]
 - [ iptables, -t, nat, -I, POSTROUTING, -s, ${vpc_cidr}, -d, 0.0.0.0/0, -j, MASQUERADE ]
 - [ iptables, -A, INPUT, -s, ${vpc_cidr}, -j, ACCEPT ]
 - [ iptables, -A, INPUT, -p, tcp, --dport, 22, -m, state, --state, NEW, -j, ACCEPT ]
 - [ iptables, -I, INPUT, -m, state, --state, "ESTABLISHED,RELATED", -j, ACCEPT ]
 - [ iptables, -I, INPUT, -i, lo, -j, ACCEPT ]
 - [ iptables, -A, INPUT, -j, LOGGINGI ]
 - [ iptables, -P, INPUT, DROP ]
 - [ sh, -c, "which AWSnycast || { cd /tmp && wget ${awsnycast_deb_url} && dpkg -i awsnycast_*.deb && rm *.deb; }" ]
 - [ systemctl, start, awsnycast ]
 - chown ec2-user:ec2-user /var/log/bastion
 - chmod -R 770 /var/log/bastion
 - setfacl -Rdm other:0 /var/log/bastion
 - awk '!/AllowTcpForwarding/' /etc/ssh/sshd_config > temp && mv temp /etc/ssh/sshd_config
 - awk '!/X11Forwarding/' /etc/ssh/sshd_config > temp && mv temp /etc/ssh/sshd_config
 - echo "AllowTcpForwarding yes" >> /etc/ssh/sshd_config
 - echo "X11Forwarding no" >> /etc/ssh/sshd_config
 - echo "ClientAliveInterval 120" >> /etc/ssh/sshd_config
 - echo "ClientAliveCountMax 720" >> /etc/ssh/sshd_config
 - chmod a+x /usr/bin/bastion/shell
 - chown root:ec2-user /usr/bin/script
 - chmod g+s /usr/bin/script
 - mount -o remount,rw,hidepid=2 /proc
 - awk '!/proc/' /etc/fstab > temp && mv temp /etc/fstab
 - echo "proc /proc proc defaults,hidepid=2 0 0" >> /etc/fstab
 - service sshd restart
 - crontab ~/mycron
 - rm ~/mycron